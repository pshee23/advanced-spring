# 섹션 2. 쓰레드 로컬 - ThreadLocal

# 필드 동기화

## 개발

로그 동기화를 위해 TraceId를 파라미터로 넘기도록 했다. 하지만 모든 메서드에 TraceId 파라미터를 추가해야 하는 문제가 발생했다. TraceId를 파라미터로 넘기지 않고 이 문제를 해결 하는 방법은?

<br/>

## 적용

 ** 수동으로 스프링빈에 등록하는법  @Configuration, @Bean

<br/>

## 동시성

### 동시성 문제

‘FieldlogTrace’는 싱글톤으로 등록된 스프링 빈이다. 이 객체의 인스턴스가 애플리케이션에 딱 1개 존재한다는 뜻이다. 이렇게 하나만 있는 인스턴스의 ‘FieldLogTrace.traceIdHolder’ 필드를 여러 쓰레드가 동시에 접근하기 때문에 문제가 발생한다. 

결과적으로 Thread-A 입장에서는 저장한 데이터와 조회한 데이터가 다른 문제가 발생한다. 이처럼 여러 쓰레드가 동시에 같은 인스턴스의 필드 값을 변경하면서 발생하는 문제를 동시성 문제라 한다. 이런 동시성 문제는 여러 쓰레드가 같은 인스턴스의 필드에 접근해야 하기 때문에 트래픽이 적은 상황에서는 확률상 잘 나타나지 않고, 트래픽이 점점 많아질수록 자주 발생한다. 

특히 스프링 빈 처럼 싱글톤 객체의 필드를 변경하며 사용할 때 이러한 동시성 문제를 조심해야 한다. 

<br/>

### 참고

이런 동시성 문제는 지역 변수에서는 발생하지 않는다. 지역 변수는 쓰레드마다 각각 다른 메모리 영역이 할당된다. 동시성 문제가 발생하는 곳은 같은 인스턴스의 필드(주로 싱글톤에서 발생), 또는 static 같은 공용 필드에 접근할 때 발생한다. 동시성 문제는 값을 읽기만 하면 발생하지 않는다. 어디선가 값을 변경하기 때문에 발생한다.

그렇다면 지금처럼 싱글톤 객체의 필드를 사용하면서 동시성 문제를 해결하려면? 

<br/>

---

<br/>

# ThreadLocal

## 소개

쓰레드 로컬은 해당 쓰레드만 접근할 수 있는 특별한 저장소를 말한다. 여러 사람이 같은 물건 보관 창구를 사용하더라도 창구 직원은 사용자를 인식해서 사용자별로 확실하게 물건을 구분해준다.

- 값 저장 : ThreadLocal.set(xxx)
- 값 조회 : ThreadLocal.get()
- 값 제거 : ThreadLocal.remove()

<aside>
⚠️ 주의
해당 쓰레드가 쓰레드 로컬을 모두 사용하고 나면 ‘ThreadLocal.remove()’ 를 호출해서 쓰레드 로컬에 저장된 값을 제거해주어야 한다.

</aside>

<br/>

## 주의 사항

쓰레드 로컬의 값을 사용후 제거하지 않고 그냥 두면 WAS(톰캣)처럼 쓰레드 풀을 사용하는 경우에 심각한 문제가 발생할 수 있다. 

“사용자A 저장 요청”

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b4bd5ba8-77b0-4f87-a00a-015b33e20522/Untitled.png)

1. 사용자A가 저장 HTTP를 요청했다.

“사용자A 저장 요청 종료”

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a7c5d451-3052-4a12-b947-b0d5ec7a9a71/Untitled.png)

1. 사용자A의 HTTP 응답이 끝난다.
2. WAS는 사용이 끝난 thread-A

“사용자B 조회 요청”

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d4d447a1-a351-453a-b8e9-a6bee728ac87/Untitled.png)

결과적으로 사용자B는 사용자A의 데이터를 확인하게 되는 문제가 발생한다.

꼭 사용자 요청이 끝날 때 remove를 통해서 데이터를 제거하자